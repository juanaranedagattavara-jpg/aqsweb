{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/layout-router.js"],"sourcesContent":["\"use client\";\n\nimport React, { useContext, use, startTransition, Suspense } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { CacheStates, LayoutRouterContext, GlobalLayoutRouterContext, TemplateContext } from \"../../shared/lib/app-router-context.shared-runtime\";\nimport { fetchServerResponse } from \"./router-reducer/fetch-server-response\";\nimport { createInfinitePromise } from \"./infinite-promise\";\nimport { ErrorBoundary } from \"./error-boundary\";\nimport { matchSegment } from \"./match-segments\";\nimport { handleSmoothScroll } from \"../../shared/lib/router/utils/handle-smooth-scroll\";\nimport { RedirectBoundary } from \"./redirect-boundary\";\nimport { NotFoundBoundary } from \"./not-found-boundary\";\nimport { getSegmentValue } from \"./router-reducer/reducers/get-segment-value\";\nimport { createRouterCacheKey } from \"./router-reducer/create-router-cache-key\";\nimport { createRecordFromThenable } from \"./router-reducer/create-record-from-thenable\";\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if (matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (typeof window === \"undefined\") return null;\n    // Only apply strict mode warning when not in production\n    if (process.env.NODE_ENV !== \"production\") {\n        const originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return ReactDOM.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return ReactDOM.findDOMNode(instance);\n}\nconst rectProperties = [\n    \"bottom\",\n    \"height\",\n    \"left\",\n    \"right\",\n    \"top\",\n    \"width\",\n    \"x\",\n    \"y\"\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        \"sticky\",\n        \"fixed\"\n    ].includes(getComputedStyle(element).position)) {\n        if (process.env.NODE_ENV === \"development\") {\n            console.warn(\"Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:\", element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === \"top\") {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends React.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args);\n        this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>matchSegment(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                handleSmoothScroll(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath, children } = param;\n    const context = useContext(GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    return /*#__PURE__*/ React.createElement(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef\n    }, children);\n}\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey, url, childNodes, childProp, segmentPath, tree, // TODO-APP: implement `<Offscreen>` when available.\n    // isActive,\n    cacheKey } = param;\n    const context = useContext(GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { buildId, changeByServerResponse, tree: fullTree } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(cacheKey);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null) {\n        if (!childNode) {\n            // Add the segment's subTreeData to the cache.\n            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n            childNode = {\n                status: CacheStates.READY,\n                data: null,\n                subTreeData: childProp.current,\n                parallelRoutes: new Map()\n            };\n            childNodes.set(cacheKey, childNode);\n        } else {\n            if (childNode.status === CacheStates.LAZY_INITIALIZED) {\n                // @ts-expect-error we're changing it's type!\n                childNode.status = CacheStates.READY;\n                // @ts-expect-error\n                childNode.subTreeData = childProp.current;\n            }\n        }\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode || childNode.status === CacheStates.LAZY_INITIALIZED) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch([\n            \"\",\n            ...segmentPath\n        ], fullTree);\n        childNode = {\n            status: CacheStates.DATA_FETCH,\n            data: createRecordFromThenable(fetchServerResponse(new URL(url, location.origin), refetchTree, context.nextUrl, buildId)),\n            subTreeData: null,\n            head: childNode && childNode.status === CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n            parallelRoutes: childNode && childNode.status === CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n        };\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(cacheKey, childNode);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = use(childNode.data);\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            startTransition(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        use(createInfinitePromise());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        use(createInfinitePromise());\n    }\n    const subtree = // The layout router context narrows down tree and childNodes at each level.\n    /*#__PURE__*/ React.createElement(LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        }\n    }, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children, loading, loadingStyles, loadingScripts, hasLoading } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ React.createElement(Suspense, {\n            fallback: /*#__PURE__*/ React.createElement(React.Fragment, null, loadingStyles, loadingScripts, loading)\n        }, children);\n    }\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, children);\n}\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */ export default function OuterLayoutRouter(param) {\n    let { parallelRouterKey, segmentPath, childProp, error, errorStyles, errorScripts, templateStyles, templateScripts, loading, loadingStyles, loadingScripts, hasLoading, template, notFound, notFoundStyles, styles } = param;\n    const context = useContext(LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes, tree, url } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodesForParallelRouter = new Map();\n        childNodes.set(parallelRouterKey, childNodesForParallelRouter);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    const childPropSegment = childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegmentValue = getSegmentValue(treeSegment);\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, styles, preservedSegments.map((preservedSegment)=>{\n        const isChildPropSegment = matchSegment(preservedSegment, childPropSegment);\n        const preservedSegmentValue = getSegmentValue(preservedSegment);\n        const cacheKey = createRouterCacheKey(preservedSegment);\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ React.createElement(TemplateContext.Provider, {\n            key: createRouterCacheKey(preservedSegment, true),\n            value: /*#__PURE__*/ React.createElement(ScrollAndFocusHandler, {\n                segmentPath: segmentPath\n            }, /*#__PURE__*/ React.createElement(ErrorBoundary, {\n                errorComponent: error,\n                errorStyles: errorStyles,\n                errorScripts: errorScripts\n            }, /*#__PURE__*/ React.createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading,\n                loadingStyles: loadingStyles,\n                loadingScripts: loadingScripts\n            }, /*#__PURE__*/ React.createElement(NotFoundBoundary, {\n                notFound: notFound,\n                notFoundStyles: notFoundStyles\n            }, /*#__PURE__*/ React.createElement(RedirectBoundary, null, /*#__PURE__*/ React.createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: isChildPropSegment ? childProp : null,\n                segmentPath: segmentPath,\n                cacheKey: cacheKey,\n                isActive: currentChildSegmentValue === preservedSegmentValue\n            }))))))\n        }, templateStyles, templateScripts, template));\n    }));\n}\n\n//# sourceMappingURL=layout-router.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}