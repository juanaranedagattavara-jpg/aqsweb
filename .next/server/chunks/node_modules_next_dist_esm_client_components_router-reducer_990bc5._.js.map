{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/get-segment-value.js"],"sourcesContent":["export function getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\n\n//# sourceMappingURL=get-segment-value.js.map"],"names":[],"mappings":";;;AAAO,SAAS,gBAAgB,OAAO;IACnC,OAAO,MAAM,OAAO,CAAC,WAAW,OAAO,CAAC,EAAE,GAAG;AACjD,EAEA,6CAA6C"}},
    {"offset": {"line": 11, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js"],"sourcesContent":["export function createRouterCacheKey(segment, withoutSearchParameters) {\n    if (withoutSearchParameters === void 0) withoutSearchParameters = false;\n    return Array.isArray(segment) ? (segment[0] + \"|\" + segment[1] + \"|\" + segment[2]).toLowerCase() : withoutSearchParameters && segment.startsWith(\"__PAGE__\") ? \"__PAGE__\" : segment;\n}\n\n//# sourceMappingURL=create-router-cache-key.js.map"],"names":[],"mappings":";;;AAAO,SAAS,qBAAqB,OAAO,EAAE,uBAAuB;IACjE,IAAI,4BAA4B,KAAK,GAAG,0BAA0B;IAClE,OAAO,MAAM,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE,GAAG,MAAM,OAAO,CAAC,EAAE,GAAG,MAAM,OAAO,CAAC,EAAE,EAAE,WAAW,KAAK,2BAA2B,QAAQ,UAAU,CAAC,cAAc,aAAa;AAChL,EAEA,mDAAmD"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/find-head-in-cache.js"],"sourcesContent":["import { createRouterCacheKey } from \"../create-router-cache-key\";\nexport function findHeadInCache(cache, parallelRoutes) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        return cache.head;\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = createRouterCacheKey(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCache(cacheNode, childParallelRoutes);\n        if (item) {\n            return item;\n        }\n    }\n    return undefined;\n}\n\n//# sourceMappingURL=find-head-in-cache.js.map"],"names":[],"mappings":";;;;;;AACO,SAAS,gBAAgB,KAAK,EAAE,cAAc;IACjD,MAAM,aAAa,OAAO,IAAI,CAAC,gBAAgB,MAAM,KAAK;IAC1D,IAAI,YAAY;QACZ,OAAO,MAAM,IAAI;IACrB;IACA,IAAI,MAAM,OAAO,eAAe;QAC5B,MAAM,CAAC,SAAS,oBAAoB,GAAG,cAAc,CAAC,IAAI;QAC1D,MAAM,kBAAkB,MAAM,cAAc,CAAC,GAAG,CAAC;QACjD,IAAI,CAAC,iBAAiB;YAClB;QACJ;QACA,MAAM,WAAW,sOAAqB;QACtC,MAAM,YAAY,gBAAgB,GAAG,CAAC;QACtC,IAAI,CAAC,WAAW;YACZ;QACJ;QACA,MAAM,OAAO,gBAAgB,WAAW;QACxC,IAAI,MAAM;YACN,OAAO;QACX;IACJ;IACA,OAAO;AACX,EAEA,8CAA8C"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/compute-changed-path.js"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from \"../../../server/future/helpers/interception-routes\";\nimport { isGroupSegment } from \"../../../shared/lib/segment\";\nimport { matchSegment } from \"../match-segments\";\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === \"/\" ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === \"string\") {\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === \"\" || isGroupSegment(segment)) {\n            return acc;\n        }\n        return acc + \"/\" + segment;\n    }, \"\") || \"/\";\n}\nexport function extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === \"__DEFAULT__\" || INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(\"__PAGE__\")) return \"\";\n    const segments = [\n        segment\n    ];\n    var _flightRouterState_;\n    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === \"children\") continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return \"\";\n    }\n    if (!matchSegment(segmentA, segmentB)) {\n        var _extractPathFromFlightRouterState;\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : \"\";\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return segmentToPathname(segmentB) + \"/\" + changedPath;\n            }\n        }\n    }\n    return null;\n}\nexport function computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === \"/\") {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split(\"/\"));\n}\n\n//# sourceMappingURL=compute-changed-path.js.map"],"names":[],"mappings":";;;;;;;;;;;AAGA,MAAM,qBAAqB,CAAC;IACxB,OAAO,OAAO,CAAC,EAAE,KAAK,MAAM,QAAQ,KAAK,CAAC,KAAK;AACnD;AACA,MAAM,oBAAoB,CAAC;IACvB,IAAI,OAAO,YAAY,UAAU;QAC7B,OAAO;IACX;IACA,OAAO,OAAO,CAAC,EAAE;AACrB;AACA,SAAS,kBAAkB,QAAQ;IAC/B,OAAO,SAAS,MAAM,CAAC,CAAC,KAAK;QACzB,UAAU,mBAAmB;QAC7B,IAAI,YAAY,MAAM,2KAAe,UAAU;YAC3C,OAAO;QACX;QACA,OAAO,MAAM,MAAM;IACvB,GAAG,OAAO;AACd;AACO,SAAS,iCAAiC,iBAAiB;IAC9D,MAAM,UAAU,MAAM,OAAO,CAAC,iBAAiB,CAAC,EAAE,IAAI,iBAAiB,CAAC,EAAE,CAAC,EAAE,GAAG,iBAAiB,CAAC,EAAE;IACpG,IAAI,YAAY,iBAAiB,oNAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC,KAAK,OAAO;IACrG,IAAI,QAAQ,UAAU,CAAC,aAAa,OAAO;IAC3C,MAAM,WAAW;QACb;KACH;IACD,IAAI;IACJ,MAAM,iBAAiB,CAAC,sBAAsB,iBAAiB,CAAC,EAAE,KAAK,OAAO,sBAAsB,CAAC;IACrG,MAAM,eAAe,eAAe,QAAQ,GAAG,iCAAiC,eAAe,QAAQ,IAAI;IAC3G,IAAI,iBAAiB,WAAW;QAC5B,SAAS,IAAI,CAAC;IAClB,OAAO;QACH,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,gBAAgB;YACtD,IAAI,QAAQ,YAAY;YACxB,MAAM,YAAY,iCAAiC;YACnD,IAAI,cAAc,WAAW;gBACzB,SAAS,IAAI,CAAC;YAClB;QACJ;IACJ;IACA,OAAO,kBAAkB;AAC7B;AACA,SAAS,uBAAuB,KAAK,EAAE,KAAK;IACxC,MAAM,CAAC,UAAU,gBAAgB,GAAG;IACpC,MAAM,CAAC,UAAU,gBAAgB,GAAG;IACpC,MAAM,qBAAqB,kBAAkB;IAC7C,MAAM,qBAAqB,kBAAkB;IAC7C,IAAI,oNAA2B,IAAI,CAAC,CAAC,IAAI,mBAAmB,UAAU,CAAC,MAAM,mBAAmB,UAAU,CAAC,KAAK;QAC5G,OAAO;IACX;IACA,IAAI,CAAC,0LAAa,UAAU,WAAW;QACnC,IAAI;QACJ,8FAA8F;QAC9F,OAAO,CAAC,oCAAoC,iCAAiC,MAAM,KAAK,OAAO,oCAAoC;IACvI;IACA,IAAI,MAAM,qBAAqB,gBAAgB;QAC3C,IAAI,eAAe,CAAC,kBAAkB,EAAE;YACpC,MAAM,cAAc,uBAAuB,eAAe,CAAC,kBAAkB,EAAE,eAAe,CAAC,kBAAkB;YACjH,IAAI,gBAAgB,MAAM;gBACtB,OAAO,kBAAkB,YAAY,MAAM;YAC/C;QACJ;IACJ;IACA,OAAO;AACX;AACO,SAAS,mBAAmB,KAAK,EAAE,KAAK;IAC3C,MAAM,cAAc,uBAAuB,OAAO;IAClD,IAAI,eAAe,QAAQ,gBAAgB,KAAK;QAC5C,OAAO;IACX;IACA,mDAAmD;IACnD,OAAO,kBAAkB,YAAY,KAAK,CAAC;AAC/C,EAEA,gDAAgD"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js"],"sourcesContent":["import { CacheStates } from \"../../../shared/lib/app-router-context.shared-runtime\";\nimport { createRouterCacheKey } from \"./create-router-cache-key\";\nexport function fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head, wasPrefetched) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = createRouterCacheKey(segmentForParallelRoute);\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                const newCacheNode = wasPrefetched && existingCacheNode ? {\n                    status: existingCacheNode.status,\n                    data: existingCacheNode.data,\n                    subTreeData: existingCacheNode.subTreeData,\n                    parallelRoutes: new Map(existingCacheNode.parallelRoutes)\n                } : {\n                    status: CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes)\n                };\n                // Overrides the cache key with the new cache node.\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                // Traverse deeper to apply the head / fill lazy items till the head.\n                fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, head, wasPrefetched);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        const newCacheNode = {\n            status: CacheStates.LAZY_INITIALIZED,\n            data: null,\n            subTreeData: null,\n            parallelRoutes: new Map()\n        };\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head, wasPrefetched);\n    }\n}\n\n//# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map"],"names":[],"mappings":";;;;;;;;AAEO,SAAS,8BAA8B,QAAQ,EAAE,aAAa,EAAE,WAAW,EAAE,IAAI,EAAE,aAAa;IACnG,MAAM,gBAAgB,OAAO,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,MAAM,KAAK;IAC7D,IAAI,eAAe;QACf,SAAS,IAAI,GAAG;QAChB;IACJ;IACA,+FAA+F;IAC/F,IAAI,MAAM,OAAO,WAAW,CAAC,EAAE,CAAC;QAC5B,MAAM,qBAAqB,WAAW,CAAC,EAAE,CAAC,IAAI;QAC9C,MAAM,0BAA0B,kBAAkB,CAAC,EAAE;QACrD,MAAM,WAAW,sOAAqB;QACtC,IAAI,eAAe;YACf,MAAM,kCAAkC,cAAc,cAAc,CAAC,GAAG,CAAC;YACzE,IAAI,iCAAiC;gBACjC,IAAI,yBAAyB,IAAI,IAAI;gBACrC,MAAM,oBAAoB,uBAAuB,GAAG,CAAC;gBACrD,MAAM,eAAe,iBAAiB,oBAAoB;oBACtD,QAAQ,kBAAkB,MAAM;oBAChC,MAAM,kBAAkB,IAAI;oBAC5B,aAAa,kBAAkB,WAAW;oBAC1C,gBAAgB,IAAI,IAAI,kBAAkB,cAAc;gBAC5D,IAAI;oBACA,QAAQ,gPAAY,gBAAgB;oBACpC,MAAM;oBACN,aAAa;oBACb,gBAAgB,IAAI,IAAI,qBAAqB,OAAO,KAAK,IAAI,kBAAkB,cAAc;gBACjG;gBACA,mDAAmD;gBACnD,uBAAuB,GAAG,CAAC,UAAU;gBACrC,qEAAqE;gBACrE,8BAA8B,cAAc,mBAAmB,oBAAoB,MAAM;gBACzF,SAAS,cAAc,CAAC,GAAG,CAAC,KAAK;gBACjC;YACJ;QACJ;QACA,MAAM,eAAe;YACjB,QAAQ,gPAAY,gBAAgB;YACpC,MAAM;YACN,aAAa;YACb,gBAAgB,IAAI;QACxB;QACA,MAAM,yBAAyB,SAAS,cAAc,CAAC,GAAG,CAAC;QAC3D,IAAI,wBAAwB;YACxB,uBAAuB,GAAG,CAAC,UAAU;QACzC,OAAO;YACH,SAAS,cAAc,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI;gBACrC;oBACI;oBACA;iBACH;aACJ;QACL;QACA,8BAA8B,cAAc,WAAW,oBAAoB,MAAM;IACrF;AACJ,EAEA,+DAA+D"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/create-href-from-url.js"],"sourcesContent":["export function createHrefFromUrl(url, includeHash) {\n    if (includeHash === void 0) includeHash = true;\n    return url.pathname + url.search + (includeHash ? url.hash : \"\");\n}\n\n//# sourceMappingURL=create-href-from-url.js.map"],"names":[],"mappings":";;;AAAO,SAAS,kBAAkB,GAAG,EAAE,WAAW;IAC9C,IAAI,gBAAgB,KAAK,GAAG,cAAc;IAC1C,OAAO,IAAI,QAAQ,GAAG,IAAI,MAAM,GAAG,CAAC,cAAc,IAAI,IAAI,GAAG,EAAE;AACnE,EAEA,gDAAgD"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/create-initial-router-state.js"],"sourcesContent":["import { CacheStates } from \"../../../shared/lib/app-router-context.shared-runtime\";\nimport { createHrefFromUrl } from \"./create-href-from-url\";\nimport { fillLazyItemsTillLeafWithHead } from \"./fill-lazy-items-till-leaf-with-head\";\nimport { extractPathFromFlightRouterState } from \"./compute-changed-path\";\nexport function createInitialRouterState(param) {\n    let { buildId, initialTree, children, initialCanonicalUrl, initialParallelRoutes, isServer, location, initialHead } = param;\n    const cache = {\n        status: CacheStates.READY,\n        data: null,\n        subTreeData: children,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: isServer ? new Map() : initialParallelRoutes\n    };\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        fillLazyItemsTillLeafWithHead(cache, undefined, initialTree, initialHead);\n    }\n    var // the || operator is intentional, the pathname can be an empty string\n    _ref;\n    return {\n        buildId,\n        tree: initialTree,\n        cache,\n        prefetchCache: new Map(),\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl: // location.href is read as the initial value for canonicalUrl in the browser\n        // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n        location ? createHrefFromUrl(location) : initialCanonicalUrl,\n        nextUrl: (_ref = extractPathFromFlightRouterState(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n}\n\n//# sourceMappingURL=create-initial-router-state.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAIO,SAAS,yBAAyB,KAAK;IAC1C,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,GAAG;IACtH,MAAM,QAAQ;QACV,QAAQ,gPAAY,KAAK;QACzB,MAAM;QACN,aAAa;QACb,oJAAoJ;QACpJ,gBAAgB,WAAW,IAAI,QAAQ;IAC3C;IACA,yEAAyE;IACzE,IAAI,0BAA0B,QAAQ,sBAAsB,IAAI,KAAK,GAAG;QACpE,oQAA8B,OAAO,WAAW,aAAa;IACjE;IACA,IACA;IACA,OAAO;QACH;QACA,MAAM;QACN;QACA,eAAe,IAAI;QACnB,SAAS;YACL,aAAa;YACb,eAAe;QACnB;QACA,mBAAmB;YACf,OAAO;YACP,gBAAgB;YAChB,cAAc;YACd,cAAc,EAAE;QACpB;QACA,cACA,kJAAkJ;QAClJ,WAAW,gOAAkB,YAAY;QACzC,SAAS,CAAC,OAAO,4OAAiC,gBAAgB,CAAC,YAAY,OAAO,KAAK,IAAI,SAAS,QAAQ,CAAC,KAAK,OAAO,OAAO;IACxI;AACJ,EAEA,uDAAuD"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/router-reducer-types.js"],"sourcesContent":["export const ACTION_REFRESH = \"refresh\";\nexport const ACTION_NAVIGATE = \"navigate\";\nexport const ACTION_RESTORE = \"restore\";\nexport const ACTION_SERVER_PATCH = \"server-patch\";\nexport const ACTION_PREFETCH = \"prefetch\";\nexport const ACTION_FAST_REFRESH = \"fast-refresh\";\nexport const ACTION_SERVER_ACTION = \"server-action\";\nexport var PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n})(PrefetchKind || (PrefetchKind = {}));\n\n//# sourceMappingURL=router-reducer-types.js.map"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB,MAAM,iBAAiB;AACvB,MAAM,sBAAsB;AAC5B,MAAM,kBAAkB;AACxB,MAAM,sBAAsB;AAC5B,MAAM,uBAAuB;AAC7B,IAAI;AACX,CAAC,SAAS,YAAY;IAClB,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,YAAY,GAAG;AAChC,CAAC,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC,IAErC,gDAAgD"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/handle-mutable.js"],"sourcesContent":["import { computeChangedPath } from \"./compute-changed-path\";\nexport function handleMutable(state, mutable) {\n    var _mutable_canonicalUrl;\n    var _mutable_shouldScroll;\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != null ? _mutable_shouldScroll : true;\n    var _mutable_scrollableSegments, _computeChangedPath;\n    return {\n        buildId: state.buildId,\n        // Set href.\n        canonicalUrl: mutable.canonicalUrl != null ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,\n        pushRef: {\n            pendingPush: mutable.pendingPush != null ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: mutable.mpaNavigation != null ? mutable.mpaNavigation : state.pushRef.mpaNavigation\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? (mutable == null ? void 0 : mutable.scrollableSegments) !== undefined ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: !!mutable.hashFragment && state.canonicalUrl.split(\"#\", 1)[0] === ((_mutable_canonicalUrl = mutable.canonicalUrl) == null ? void 0 : _mutable_canonicalUrl.split(\"#\", 1)[0]),\n            hashFragment: shouldScroll ? // #top is handled in layout-router.\n            mutable.hashFragment && mutable.hashFragment !== \"\" ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,\n        // Apply patched router state.\n        tree: mutable.patchedTree !== undefined ? mutable.patchedTree : state.tree,\n        nextUrl: mutable.patchedTree !== undefined ? (_computeChangedPath = computeChangedPath(state.tree, mutable.patchedTree)) != null ? _computeChangedPath : state.canonicalUrl : state.nextUrl\n    };\n}\n\n//# sourceMappingURL=handle-mutable.js.map"],"names":[],"mappings":";;;;;;AACO,SAAS,cAAc,KAAK,EAAE,OAAO;IACxC,IAAI;IACJ,IAAI;IACJ,0DAA0D;IAC1D,MAAM,eAAe,CAAC,wBAAwB,QAAQ,YAAY,KAAK,OAAO,wBAAwB;IACtG,IAAI,6BAA6B;IACjC,OAAO;QACH,SAAS,MAAM,OAAO;QACtB,YAAY;QACZ,cAAc,QAAQ,YAAY,IAAI,OAAO,QAAQ,YAAY,KAAK,MAAM,YAAY,GAAG,MAAM,YAAY,GAAG,QAAQ,YAAY,GAAG,MAAM,YAAY;QACzJ,SAAS;YACL,aAAa,QAAQ,WAAW,IAAI,OAAO,QAAQ,WAAW,GAAG,MAAM,OAAO,CAAC,WAAW;YAC1F,eAAe,QAAQ,aAAa,IAAI,OAAO,QAAQ,aAAa,GAAG,MAAM,OAAO,CAAC,aAAa;QACtG;QACA,kEAAkE;QAClE,mBAAmB;YACf,OAAO,eAAe,CAAC,WAAW,OAAO,KAAK,IAAI,QAAQ,kBAAkB,MAAM,YAAY,OAAO,MAAM,iBAAiB,CAAC,KAAK,GAAG;YACrI,gBAAgB,CAAC,CAAC,QAAQ,YAAY,IAAI,MAAM,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC,wBAAwB,QAAQ,YAAY,KAAK,OAAO,KAAK,IAAI,sBAAsB,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;YAC3L,cAAc,eACd,QAAQ,YAAY,IAAI,QAAQ,YAAY,KAAK,KAAK,mBAAmB,QAAQ,YAAY,CAAC,KAAK,CAAC,MAAM,MAAM,iBAAiB,CAAC,YAAY,GAAG;YACjJ,cAAc,eAAe,CAAC,8BAA8B,WAAW,OAAO,KAAK,IAAI,QAAQ,kBAAkB,KAAK,OAAO,8BAA8B,MAAM,iBAAiB,CAAC,YAAY,GAAG,EAAE;QACxM;QACA,eAAe;QACf,OAAO,QAAQ,KAAK,GAAG,QAAQ,KAAK,GAAG,MAAM,KAAK;QAClD,eAAe,QAAQ,aAAa,GAAG,QAAQ,aAAa,GAAG,MAAM,aAAa;QAClF,8BAA8B;QAC9B,MAAM,QAAQ,WAAW,KAAK,YAAY,QAAQ,WAAW,GAAG,MAAM,IAAI;QAC1E,SAAS,QAAQ,WAAW,KAAK,YAAY,CAAC,sBAAsB,8NAAmB,MAAM,IAAI,EAAE,QAAQ,WAAW,CAAC,KAAK,OAAO,sBAAsB,MAAM,YAAY,GAAG,MAAM,OAAO;IAC/L;AACJ,EAEA,0CAA0C"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/is-navigating-to-new-root-layout.js"],"sourcesContent":["export function isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\n\n//# sourceMappingURL=is-navigating-to-new-root-layout.js.map"],"names":[],"mappings":";;;AAAO,SAAS,4BAA4B,WAAW,EAAE,QAAQ;IAC7D,mBAAmB;IACnB,MAAM,qBAAqB,WAAW,CAAC,EAAE;IACzC,MAAM,kBAAkB,QAAQ,CAAC,EAAE;IACnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAI,MAAM,OAAO,CAAC,uBAAuB,MAAM,OAAO,CAAC,kBAAkB;QACrE,sHAAsH;QACtH,uGAAuG;QACvG,IAAI,kBAAkB,CAAC,EAAE,KAAK,eAAe,CAAC,EAAE,IAAI,kBAAkB,CAAC,EAAE,KAAK,eAAe,CAAC,EAAE,EAAE;YAC9F,OAAO;QACX;IACJ,OAAO,IAAI,uBAAuB,iBAAiB;QAC/C,OAAO;IACX;IACA,iCAAiC;IACjC,IAAI,WAAW,CAAC,EAAE,EAAE;QAChB,4EAA4E;QAC5E,OAAO,CAAC,QAAQ,CAAC,EAAE;IACvB;IACA,qEAAqE;IACrE,IAAI,QAAQ,CAAC,EAAE,EAAE;QACb,OAAO;IACX;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAM,mBAAmB,OAAO,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAM,gBAAgB,OAAO,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAAC,oBAAoB,CAAC,eAAe,OAAO;IAChD,OAAO,4BAA4B,kBAAkB;AACzD,EAEA,4DAA4D"}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 390, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/apply-router-state-patch-to-tree.js"],"sourcesContent":["import { matchSegment } from \"../match-segments\";\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */ function applyPatch(initialTree, patchTree) {\n    const [initialSegment, initialParallelRoutes] = initialTree;\n    const [patchSegment, patchParallelRoutes] = patchTree;\n    // if the applied patch segment is __DEFAULT__ then we can ignore it and return the initial tree\n    // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n    if (patchSegment === \"__DEFAULT__\" && initialSegment !== \"__DEFAULT__\") {\n        return initialTree;\n    }\n    if (matchSegment(initialSegment, patchSegment)) {\n        const newParallelRoutes = {};\n        for(const key in initialParallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== \"undefined\";\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);\n            } else {\n                newParallelRoutes[key] = initialParallelRoutes[key];\n            }\n        }\n        for(const key in patchParallelRoutes){\n            if (newParallelRoutes[key]) {\n                continue;\n            }\n            newParallelRoutes[key] = patchParallelRoutes[key];\n        }\n        const tree = [\n            initialSegment,\n            newParallelRoutes\n        ];\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\n/**\n * Apply the router state from the Flight response. Creates a new router state tree.\n */ export function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!matchSegment(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        {\n            ...parallelRoutes,\n            [parallelRouteKey]: parallelRoutePatch\n        }\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    return tree;\n}\n\n//# sourceMappingURL=apply-router-state-patch-to-tree.js.map"],"names":[],"mappings":";;;;;;AACA;;CAEC,GAAG,SAAS,WAAW,WAAW,EAAE,SAAS;IAC1C,MAAM,CAAC,gBAAgB,sBAAsB,GAAG;IAChD,MAAM,CAAC,cAAc,oBAAoB,GAAG;IAC5C,gGAAgG;IAChG,iFAAiF;IACjF,IAAI,iBAAiB,iBAAiB,mBAAmB,eAAe;QACpE,OAAO;IACX;IACA,IAAI,0LAAa,gBAAgB,eAAe;QAC5C,MAAM,oBAAoB,CAAC;QAC3B,IAAI,MAAM,OAAO,sBAAsB;YACnC,MAAM,8BAA8B,OAAO,mBAAmB,CAAC,IAAI,KAAK;YACxE,IAAI,6BAA6B;gBAC7B,iBAAiB,CAAC,IAAI,GAAG,WAAW,qBAAqB,CAAC,IAAI,EAAE,mBAAmB,CAAC,IAAI;YAC5F,OAAO;gBACH,iBAAiB,CAAC,IAAI,GAAG,qBAAqB,CAAC,IAAI;YACvD;QACJ;QACA,IAAI,MAAM,OAAO,oBAAoB;YACjC,IAAI,iBAAiB,CAAC,IAAI,EAAE;gBACxB;YACJ;YACA,iBAAiB,CAAC,IAAI,GAAG,mBAAmB,CAAC,IAAI;QACrD;QACA,MAAM,OAAO;YACT;YACA;SACH;QACD,IAAI,WAAW,CAAC,EAAE,EAAE;YAChB,IAAI,CAAC,EAAE,GAAG,WAAW,CAAC,EAAE;QAC5B;QACA,IAAI,WAAW,CAAC,EAAE,EAAE;YAChB,IAAI,CAAC,EAAE,GAAG,WAAW,CAAC,EAAE;QAC5B;QACA,IAAI,WAAW,CAAC,EAAE,EAAE;YAChB,IAAI,CAAC,EAAE,GAAG,WAAW,CAAC,EAAE;QAC5B;QACA,OAAO;IACX;IACA,OAAO;AACX;AAGW,SAAS,4BAA4B,iBAAiB,EAAE,iBAAiB,EAAE,SAAS;IAC3F,MAAM,CAAC,SAAS,oBAAoB,aAAa,GAAG;IACpD,eAAe;IACf,IAAI,kBAAkB,MAAM,KAAK,GAAG;QAChC,MAAM,OAAO,WAAW,mBAAmB;QAC3C,OAAO;IACX;IACA,MAAM,CAAC,gBAAgB,iBAAiB,GAAG;IAC3C,iGAAiG;IACjG,IAAI,CAAC,0LAAa,gBAAgB,UAAU;QACxC,OAAO;IACX;IACA,MAAM,cAAc,kBAAkB,MAAM,KAAK;IACjD,IAAI;IACJ,IAAI,aAAa;QACb,qBAAqB,WAAW,cAAc,CAAC,iBAAiB,EAAE;IACtE,OAAO;QACH,qBAAqB,4BAA4B,kBAAkB,KAAK,CAAC,IAAI,cAAc,CAAC,iBAAiB,EAAE;QAC/G,IAAI,uBAAuB,MAAM;YAC7B,OAAO;QACX;IACJ;IACA,MAAM,OAAO;QACT,iBAAiB,CAAC,EAAE;QACpB;YACI,GAAG,cAAc;YACjB,CAAC,iBAAiB,EAAE;QACxB;KACH;IACD,qCAAqC;IACrC,IAAI,cAAc;QACd,IAAI,CAAC,EAAE,GAAG;IACd;IACA,OAAO;AACX,EAEA,4DAA4D"}},
    {"offset": {"line": 474, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 479, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/get-prefetch-cache-entry-status.js"],"sourcesContent":["const FIVE_MINUTES = 5 * 60 * 1000;\nconst THIRTY_SECONDS = 30 * 1000;\nexport var PrefetchCacheEntryStatus;\n(function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n})(PrefetchCacheEntryStatus || (PrefetchCacheEntryStatus = {}));\nexport function getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // if the cache entry was prefetched or read less than 30s ago, then we want to re-use it\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + THIRTY_SECONDS) {\n        return lastUsedTime ? \"reusable\" : \"fresh\";\n    }\n    // if the cache entry was prefetched less than 5 mins ago, then we want to re-use only the loading state\n    if (kind === \"auto\") {\n        if (Date.now() < prefetchTime + FIVE_MINUTES) {\n            return \"stale\";\n        }\n    }\n    // if the cache entry was prefetched less than 5 mins ago and was a \"full\" prefetch, then we want to re-use it \"full\n    if (kind === \"full\") {\n        if (Date.now() < prefetchTime + FIVE_MINUTES) {\n            return \"reusable\";\n        }\n    }\n    return \"expired\";\n}\n\n//# sourceMappingURL=get-prefetch-cache-entry-status.js.map"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe,IAAI,KAAK;AAC9B,MAAM,iBAAiB,KAAK;AACrB,IAAI;AACX,CAAC,SAAS,wBAAwB;IAC9B,wBAAwB,CAAC,QAAQ,GAAG;IACpC,wBAAwB,CAAC,WAAW,GAAG;IACvC,wBAAwB,CAAC,UAAU,GAAG;IACtC,wBAAwB,CAAC,QAAQ,GAAG;AACxC,CAAC,EAAE,4BAA4B,CAAC,2BAA2B,CAAC,CAAC;AACtD,SAAS,4BAA4B,KAAK;IAC7C,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG;IAC3C,yFAAyF;IACzF,IAAI,KAAK,GAAG,KAAK,CAAC,gBAAgB,OAAO,eAAe,YAAY,IAAI,gBAAgB;QACpF,OAAO,eAAe,aAAa;IACvC;IACA,wGAAwG;IACxG,IAAI,SAAS,QAAQ;QACjB,IAAI,KAAK,GAAG,KAAK,eAAe,cAAc;YAC1C,OAAO;QACX;IACJ;IACA,oHAAoH;IACpH,IAAI,SAAS,QAAQ;QACjB,IAAI,KAAK,GAAG,KAAK,eAAe,cAAc;YAC1C,OAAO;QACX;IACJ;IACA,OAAO;AACX,EAEA,2DAA2D"}},
    {"offset": {"line": 512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 517, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/prune-prefetch-cache.js"],"sourcesContent":["import { PrefetchCacheEntryStatus, getPrefetchEntryCacheStatus } from \"../get-prefetch-cache-entry-status\";\nexport function prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n\n//# sourceMappingURL=prune-prefetch-cache.js.map"],"names":[],"mappings":";;;;;;AACO,SAAS,mBAAmB,aAAa;IAC5C,KAAK,MAAM,CAAC,MAAM,mBAAmB,IAAI,cAAc;QACnD,IAAI,wPAA4B,wBAAwB,qPAAyB,OAAO,EAAE;YACtF,cAAc,MAAM,CAAC;QACzB;IACJ;AACJ,EAEA,gDAAgD"}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 535, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/create-record-from-thenable.js"],"sourcesContent":["/**\n * Create data fetching record for Promise.\n */ export function createRecordFromThenable(promise) {\n    const thenable = promise;\n    thenable.status = \"pending\";\n    thenable.then((value)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"fulfilled\";\n            thenable.value = value;\n        }\n    }, (err)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"rejected\";\n            thenable.reason = err;\n        }\n    });\n    return thenable;\n}\n\n//# sourceMappingURL=create-record-from-thenable.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;AAAU,SAAS,yBAAyB,OAAO;IAChD,MAAM,WAAW;IACjB,SAAS,MAAM,GAAG;IAClB,SAAS,IAAI,CAAC,CAAC;QACX,IAAI,SAAS,MAAM,KAAK,WAAW;YAC/B,SAAS,MAAM,GAAG;YAClB,SAAS,KAAK,GAAG;QACrB;IACJ,GAAG,CAAC;QACA,IAAI,SAAS,MAAM,KAAK,WAAW;YAC/B,SAAS,MAAM,GAAG;YAClB,SAAS,MAAM,GAAG;QACtB;IACJ;IACA,OAAO;AACX,EAEA,uDAAuD"}},
    {"offset": {"line": 556, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js"],"sourcesContent":["\"use client\";\n\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\nconst { createFromFetch } = !!process.env.NEXT_RUNTIME ? require(\"react-server-dom-webpack/client.edge\") : require(\"react-server-dom-webpack/client\");\nimport { NEXT_ROUTER_PREFETCH, NEXT_ROUTER_STATE_TREE, NEXT_RSC_UNION_QUERY, NEXT_URL, RSC, RSC_CONTENT_TYPE_HEADER } from \"../app-router-headers\";\nimport { urlToUrlWithoutFlightMarker } from \"../app-router\";\nimport { callServer } from \"../../app-call-server\";\nimport { PrefetchKind } from \"./router-reducer-types\";\nimport { hexHash } from \"../../../shared/lib/hash\";\nimport { NEXT_DID_POSTPONE_HEADER } from \"../../../lib/constants\";\nfunction doMpaNavigation(url) {\n    return [\n        urlToUrlWithoutFlightMarker(url).toString(),\n        undefined\n    ];\n}\n/**\n * Fetch the flight data for the provided url. Takes in the current router state to decide what to render server-side.\n */ export async function fetchServerResponse(url, flightRouterState, nextUrl, currentBuildId, prefetchKind) {\n    const headers = {\n        // Enable flight response\n        [RSC]: \"1\",\n        // Provide the current router state\n        [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === PrefetchKind.AUTO) {\n        headers[NEXT_ROUTER_PREFETCH] = \"1\";\n    }\n    if (nextUrl) {\n        headers[NEXT_URL] = nextUrl;\n    }\n    const uniqueCacheQuery = hexHash([\n        headers[NEXT_ROUTER_PREFETCH] || \"0\",\n        headers[NEXT_ROUTER_STATE_TREE],\n        headers[NEXT_URL]\n    ].join(\",\"));\n    try {\n        let fetchUrl = new URL(url);\n        if (process.env.NODE_ENV === \"production\") {\n            if (process.env.__NEXT_CONFIG_OUTPUT === \"export\") {\n                if (fetchUrl.pathname.endsWith(\"/\")) {\n                    fetchUrl.pathname += \"index.txt\";\n                } else {\n                    fetchUrl.pathname += \".txt\";\n                }\n            }\n        }\n        // Add unique cache query to avoid caching conflicts on CDN which don't respect to Vary header\n        fetchUrl.searchParams.set(NEXT_RSC_UNION_QUERY, uniqueCacheQuery);\n        const res = await fetch(fetchUrl, {\n            // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n            credentials: \"same-origin\",\n            headers\n        });\n        const responseUrl = urlToUrlWithoutFlightMarker(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get(\"content-type\") || \"\";\n        const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER);\n        let isFlightResponse = contentType === RSC_CONTENT_TYPE_HEADER;\n        if (process.env.NODE_ENV === \"production\") {\n            if (process.env.__NEXT_CONFIG_OUTPUT === \"export\") {\n                if (!isFlightResponse) {\n                    isFlightResponse = contentType.startsWith(\"text/plain\");\n                }\n            }\n        }\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const [buildId, flightData] = await createFromFetch(Promise.resolve(res), {\n            callServer\n        });\n        if (currentBuildId !== buildId) {\n            return doMpaNavigation(res.url);\n        }\n        return [\n            flightData,\n            canonicalUrl,\n            postponed\n        ];\n    } catch (err) {\n        console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return [\n            url.toString(),\n            undefined\n        ];\n    }\n}\n\n//# sourceMappingURL=fetch-server-response.js.map"],"names":[],"mappings":";;;;;;;;;;AAAA;AAEA,aAAa;AACb,6DAA6D;AAC7D,oEAAoE;AACpE,MAAM,EAAE,eAAe,EAAE,GAAG,uCAA6B;;;;;;;AAOzD,SAAS,gBAAgB,GAAG;IACxB,OAAO;QACH,qMAA4B,KAAK,QAAQ;QACzC;KACH;AACL;AAGW,eAAe,oBAAoB,GAAG,EAAE,iBAAiB,EAAE,OAAO,EAAE,cAAc,EAAE,YAAY;IACvG,MAAM,UAAU;QACZ,yBAAyB;QACzB,yLAAK,EAAE;QACP,mCAAmC;QACnC,4MAAwB,EAAE,mBAAmB,KAAK,SAAS,CAAC;IAChE;IACA;;;;;GAKD,GAAG,IAAI,iBAAiB,wNAAa,IAAI,EAAE;QACtC,OAAO,0MAAsB,GAAG;IACpC;IACA,IAAI,SAAS;QACT,OAAO,8LAAU,GAAG;IACxB;IACA,MAAM,mBAAmB,iKAAQ;QAC7B,OAAO,0MAAsB,IAAI;QACjC,OAAO,4MAAwB;QAC/B,OAAO,8LAAU;KACpB,CAAC,IAAI,CAAC;IACP,IAAI;QACA,IAAI,WAAW,IAAI,IAAI;QACvB;;;QASA,8FAA8F;QAC9F,SAAS,YAAY,CAAC,GAAG,2MAAuB;QAChD,MAAM,MAAM,MAAM,MAAM,UAAU;YAC9B,wFAAwF;YACxF,aAAa;YACb;QACJ;QACA,MAAM,cAAc,qMAA4B,IAAI,GAAG;QACvD,MAAM,eAAe,IAAI,UAAU,GAAG,cAAc;QACpD,MAAM,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC,mBAAmB;QACvD,MAAM,YAAY,CAAC,CAAC,IAAI,OAAO,CAAC,GAAG;QACnC,IAAI,mBAAmB;QACvB;;;QAOA,4FAA4F;QAC5F,oEAAoE;QACpE,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,EAAE;YAC9B,2FAA2F;YAC3F,IAAI,IAAI,IAAI,EAAE;gBACV,YAAY,IAAI,GAAG,IAAI,IAAI;YAC/B;YACA,OAAO,gBAAgB,YAAY,QAAQ;QAC/C;QACA,2EAA2E;QAC3E,MAAM,CAAC,SAAS,WAAW,GAAG,MAAM,gBAAgB,QAAQ,OAAO,CAAC,MAAM;YACtE,UAAU;QACd;QACA,IAAI,mBAAmB,SAAS;YAC5B,OAAO,gBAAgB,IAAI,GAAG;QAClC;QACA,OAAO;YACH;YACA;YACA;SACH;IACL,EAAE,OAAO,KAAK;QACV,QAAQ,KAAK,CAAC,qCAAqC,MAAM,yCAAyC;QAClG,iDAAiD;QACjD,qHAAqH;QACrH,iGAAiG;QACjG,OAAO;YACH,IAAI,QAAQ;YACZ;SACH;IACL;AACJ,EAEA,iDAAiD"}},
    {"offset": {"line": 663, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 668, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/prefetch-reducer.js"],"sourcesContent":["import { createHrefFromUrl } from \"../create-href-from-url\";\nimport { fetchServerResponse } from \"../fetch-server-response\";\nimport { PrefetchKind } from \"../router-reducer-types\";\nimport { createRecordFromThenable } from \"../create-record-from-thenable\";\nimport { prunePrefetchCache } from \"./prune-prefetch-cache\";\nimport { NEXT_RSC_UNION_QUERY } from \"../../app-router-headers\";\nimport { PromiseQueue } from \"../../promise-queue\";\nexport const prefetchQueue = new PromiseQueue(5);\nexport function prefetchReducer(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    prunePrefetchCache(state.prefetchCache);\n    const { url } = action;\n    url.searchParams.delete(NEXT_RSC_UNION_QUERY);\n    const href = createHrefFromUrl(url, // Ensures the hash is not part of the cache key as it does not affect fetching the server\n    false);\n    const cacheEntry = state.prefetchCache.get(href);\n    if (cacheEntry) {\n        /**\n     * If the cache entry present was marked as temporary, it means that we prefetched it from the navigate reducer,\n     * where we didn't have the prefetch intent. We want to update it to the new, more accurate, kind here.\n     */ if (cacheEntry.kind === PrefetchKind.TEMPORARY) {\n            state.prefetchCache.set(href, {\n                ...cacheEntry,\n                kind: action.kind\n            });\n        }\n        /**\n     * if the prefetch action was a full prefetch and that the current cache entry wasn't one, we want to re-prefetch,\n     * otherwise we can re-use the current cache entry\n     **/ if (!(cacheEntry.kind === PrefetchKind.AUTO && action.kind === PrefetchKind.FULL)) {\n            return state;\n        }\n    }\n    // fetchServerResponse is intentionally not awaited so that it can be unwrapped in the navigate-reducer\n    const serverResponse = createRecordFromThenable(prefetchQueue.enqueue(()=>fetchServerResponse(url, // initialTree is used when history.state.tree is missing because the history state is set in `useEffect` below, it being missing means this is the hydration case.\n        state.tree, state.nextUrl, state.buildId, action.kind)));\n    // Create new tree based on the flightSegmentPath and router state patch\n    state.prefetchCache.set(href, {\n        // Create new tree based on the flightSegmentPath and router state patch\n        treeAtTimeOfPrefetch: state.tree,\n        data: serverResponse,\n        kind: action.kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null\n    });\n    return state;\n}\n\n//# sourceMappingURL=prefetch-reducer.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAOO,MAAM,gBAAgB,6LAAiB;AACvC,SAAS,gBAAgB,KAAK,EAAE,MAAM;IACzC,4DAA4D;IAC5D,0OAAmB,MAAM,aAAa;IACtC,MAAM,EAAE,GAAG,EAAE,GAAG;IAChB,IAAI,YAAY,CAAC,MAAM;IACvB,MAAM,OAAO,gOAAkB,KAC/B;IACA,MAAM,aAAa,MAAM,aAAa,CAAC,GAAG,CAAC;IAC3C,IAAI,YAAY;QACZ;;;KAGH,GAAG,IAAI,WAAW,IAAI,KAAK,wNAAa,SAAS,EAAE;YAC5C,MAAM,aAAa,CAAC,GAAG,CAAC,MAAM;gBAC1B,GAAG,UAAU;gBACb,MAAM,OAAO,IAAI;YACrB;QACJ;QACA;;;MAGF,GAAG,IAAI,CAAC,CAAC,WAAW,IAAI,KAAK,wNAAa,IAAI,IAAI,OAAO,IAAI,KAAK,wNAAa,IAAI,GAAG;YAChF,OAAO;QACX;IACJ;IACA,uGAAuG;IACvG,MAAM,iBAAiB,8OAAyB,cAAc,OAAO,CAAC,IAAI,gOAAoB,KAC1F,MAAM,IAAI,EAAE,MAAM,OAAO,EAAE,MAAM,OAAO,EAAE,OAAO,IAAI;IACzD,wEAAwE;IACxE,MAAM,aAAa,CAAC,GAAG,CAAC,MAAM;QAC1B,wEAAwE;QACxE,sBAAsB,MAAM,IAAI;QAChC,MAAM;QACN,MAAM,OAAO,IAAI;QACjB,cAAc,KAAK,GAAG;QACtB,cAAc;IAClB;IACA,OAAO;AACX,EAEA,4CAA4C"}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 730, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/invalidate-cache-by-router-state.js"],"sourcesContent":["import { createRouterCacheKey } from \"./create-router-cache-key\";\n/**\n * Invalidate cache one level down from the router state.\n */ export function invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = createRouterCacheKey(segmentForParallelRoute);\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\n\n//# sourceMappingURL=invalidate-cache-by-router-state.js.map"],"names":[],"mappings":";;;;;;AAGW,SAAS,6BAA6B,QAAQ,EAAE,aAAa,EAAE,WAAW;IACjF,+FAA+F;IAC/F,IAAI,MAAM,OAAO,WAAW,CAAC,EAAE,CAAC;QAC5B,MAAM,0BAA0B,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;QACtD,MAAM,WAAW,sOAAqB;QACtC,MAAM,kCAAkC,cAAc,cAAc,CAAC,GAAG,CAAC;QACzE,IAAI,iCAAiC;YACjC,IAAI,yBAAyB,IAAI,IAAI;YACrC,uBAAuB,MAAM,CAAC;YAC9B,SAAS,cAAc,CAAC,GAAG,CAAC,KAAK;QACrC;IACJ;AACJ,EAEA,4DAA4D"}},
    {"offset": {"line": 749, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 754, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/fill-cache-with-new-subtree-data.js"],"sourcesContent":["import { CacheStates } from \"../../../shared/lib/app-router-context.shared-runtime\";\nimport { invalidateCacheByRouterState } from \"./invalidate-cache-by-router-state\";\nimport { fillLazyItemsTillLeafWithHead } from \"./fill-lazy-items-till-leaf-with-head\";\nimport { createRouterCacheKey } from \"./create-router-cache-key\";\n/**\n * Fill cache with subTreeData based on flightDataPath\n */ export function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, wasPrefetched) {\n    const isLastEntry = flightDataPath.length <= 5;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const cacheKey = createRouterCacheKey(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                status: CacheStates.READY,\n                data: null,\n                subTreeData: flightDataPath[3],\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n            };\n            if (existingChildCacheNode) {\n                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4], wasPrefetched);\n            childSegmentMap.set(cacheKey, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), wasPrefetched);\n}\n\n//# sourceMappingURL=fill-cache-with-new-subtree-data.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAMW,SAAS,4BAA4B,QAAQ,EAAE,aAAa,EAAE,cAAc,EAAE,aAAa;IAClG,MAAM,cAAc,eAAe,MAAM,IAAI;IAC7C,MAAM,CAAC,kBAAkB,QAAQ,GAAG;IACpC,MAAM,WAAW,sOAAqB;IACtC,MAAM,0BAA0B,cAAc,cAAc,CAAC,GAAG,CAAC;IACjE,IAAI,CAAC,yBAAyB;QAC1B,6EAA6E;QAC7E,sEAAsE;QACtE;IACJ;IACA,IAAI,kBAAkB,SAAS,cAAc,CAAC,GAAG,CAAC;IAClD,IAAI,CAAC,mBAAmB,oBAAoB,yBAAyB;QACjE,kBAAkB,IAAI,IAAI;QAC1B,SAAS,cAAc,CAAC,GAAG,CAAC,kBAAkB;IAClD;IACA,MAAM,yBAAyB,wBAAwB,GAAG,CAAC;IAC3D,IAAI,iBAAiB,gBAAgB,GAAG,CAAC;IACzC,IAAI,aAAa;QACb,IAAI,CAAC,kBAAkB,CAAC,eAAe,IAAI,IAAI,mBAAmB,wBAAwB;YACtF,iBAAiB;gBACb,QAAQ,gPAAY,KAAK;gBACzB,MAAM;gBACN,aAAa,cAAc,CAAC,EAAE;gBAC9B,oEAAoE;gBACpE,gBAAgB,yBAAyB,IAAI,IAAI,uBAAuB,cAAc,IAAI,IAAI;YAClG;YACA,IAAI,wBAAwB;gBACxB,0PAA6B,gBAAgB,wBAAwB,cAAc,CAAC,EAAE;YAC1F;YACA,oQAA8B,gBAAgB,wBAAwB,cAAc,CAAC,EAAE,EAAE,cAAc,CAAC,EAAE,EAAE;YAC5G,gBAAgB,GAAG,CAAC,UAAU;QAClC;QACA;IACJ;IACA,IAAI,CAAC,kBAAkB,CAAC,wBAAwB;QAC5C,6EAA6E;QAC7E,sEAAsE;QACtE;IACJ;IACA,IAAI,mBAAmB,wBAAwB;QAC3C,iBAAiB;YACb,QAAQ,eAAe,MAAM;YAC7B,MAAM,eAAe,IAAI;YACzB,aAAa,eAAe,WAAW;YACvC,gBAAgB,IAAI,IAAI,eAAe,cAAc;QACzD;QACA,gBAAgB,GAAG,CAAC,UAAU;IAClC;IACA,4BAA4B,gBAAgB,wBAAwB,eAAe,KAAK,CAAC,IAAI;AACjG,EAEA,4DAA4D"}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 821, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/apply-flight-data.js"],"sourcesContent":["import { CacheStates } from \"../../../shared/lib/app-router-context.shared-runtime\";\nimport { fillLazyItemsTillLeafWithHead } from \"./fill-lazy-items-till-leaf-with-head\";\nimport { fillCacheWithNewSubTreeData } from \"./fill-cache-with-new-subtree-data\";\nexport function applyFlightData(existingCache, cache, flightDataPath, wasPrefetched) {\n    if (wasPrefetched === void 0) wasPrefetched = false;\n    // The one before last item is the router state tree patch\n    const [treePatch, subTreeData, head] = flightDataPath.slice(-3);\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (subTreeData === null) {\n        return false;\n    }\n    if (flightDataPath.length === 3) {\n        cache.status = CacheStates.READY;\n        cache.subTreeData = subTreeData;\n        fillLazyItemsTillLeafWithHead(cache, existingCache, treePatch, head, wasPrefetched);\n    } else {\n        // Copy subTreeData for the root node of the cache.\n        cache.status = CacheStates.READY;\n        cache.subTreeData = existingCache.subTreeData;\n        cache.parallelRoutes = new Map(existingCache.parallelRoutes);\n        // Create a copy of the existing cache with the subTreeData applied.\n        fillCacheWithNewSubTreeData(cache, existingCache, flightDataPath, wasPrefetched);\n    }\n    return true;\n}\n\n//# sourceMappingURL=apply-flight-data.js.map"],"names":[],"mappings":";;;;;;;;;;AAGO,SAAS,gBAAgB,aAAa,EAAE,KAAK,EAAE,cAAc,EAAE,aAAa;IAC/E,IAAI,kBAAkB,KAAK,GAAG,gBAAgB;IAC9C,0DAA0D;IAC1D,MAAM,CAAC,WAAW,aAAa,KAAK,GAAG,eAAe,KAAK,CAAC,CAAC;IAC7D,8FAA8F;IAC9F,IAAI,gBAAgB,MAAM;QACtB,OAAO;IACX;IACA,IAAI,eAAe,MAAM,KAAK,GAAG;QAC7B,MAAM,MAAM,GAAG,gPAAY,KAAK;QAChC,MAAM,WAAW,GAAG;QACpB,oQAA8B,OAAO,eAAe,WAAW,MAAM;IACzE,OAAO;QACH,mDAAmD;QACnD,MAAM,MAAM,GAAG,gPAAY,KAAK;QAChC,MAAM,WAAW,GAAG,cAAc,WAAW;QAC7C,MAAM,cAAc,GAAG,IAAI,IAAI,cAAc,cAAc;QAC3D,oEAAoE;QACpE,4PAA4B,OAAO,eAAe,gBAAgB;IACtE;IACA,OAAO;AACX,EAEA,6CAA6C"}},
    {"offset": {"line": 853, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/should-hard-navigate.js"],"sourcesContent":["import { matchSegment } from \"../match-segments\";\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!matchSegment(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\n\n//# sourceMappingURL=should-hard-navigate.js.map"],"names":[],"mappings":";;;;;;AAEO,SAAS,mBAAmB,iBAAiB,EAAE,iBAAiB;IACnE,MAAM,CAAC,SAAS,eAAe,GAAG;IAClC,2CAA2C;IAC3C,MAAM,CAAC,gBAAgB,iBAAiB,GAAG;IAC3C,yDAAyD;IACzD,IAAI,CAAC,0LAAa,gBAAgB,UAAU;QACxC,kGAAkG;QAClG,IAAI,MAAM,OAAO,CAAC,iBAAiB;YAC/B,OAAO;QACX;QACA,sEAAsE;QACtE,OAAO;IACX;IACA,MAAM,cAAc,kBAAkB,MAAM,IAAI;IAChD,IAAI,aAAa;QACb,OAAO;IACX;IACA,OAAO,mBAAmB,kBAAkB,KAAK,CAAC,IAAI,cAAc,CAAC,iBAAiB;AAC1F,EAEA,gDAAgD"}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 888, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/create-optimistic-tree.js"],"sourcesContent":["import { matchSegment } from \"../match-segments\";\n/**\n * Create optimistic version of router state based on the existing router state and segments.\n * This is used to allow rendering layout-routers up till the point where data is missing.\n */ export function createOptimisticTree(segments, flightRouterState, parentRefetch) {\n    const [existingSegment, existingParallelRoutes, url, refresh, isRootLayout] = flightRouterState || [\n        null,\n        {}\n    ];\n    const segment = segments[0];\n    const isLastSegment = segments.length === 1;\n    const segmentMatches = existingSegment !== null && matchSegment(existingSegment, segment);\n    // if there are multiple parallel routes at this level, we need to refetch here\n    // to ensure we get the correct tree. This is because we don't know which\n    // parallel route will match the next segment.\n    const hasMultipleParallelRoutes = Object.keys(existingParallelRoutes).length > 1;\n    const shouldRefetchThisLevel = !flightRouterState || !segmentMatches || hasMultipleParallelRoutes;\n    let parallelRoutes = {};\n    if (existingSegment !== null && segmentMatches) {\n        parallelRoutes = existingParallelRoutes;\n    }\n    let childTree;\n    // if there's multiple parallel routes at this level, we shouldn't create an\n    // optimistic tree for the next level because we don't know which one will\n    // match the next segment.\n    if (!isLastSegment && !hasMultipleParallelRoutes) {\n        const childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, parentRefetch || shouldRefetchThisLevel);\n        childTree = childItem;\n    }\n    const result = [\n        segment,\n        {\n            ...parallelRoutes,\n            ...childTree ? {\n                children: childTree\n            } : {}\n        }\n    ];\n    if (url) {\n        result[2] = url;\n    }\n    if (!parentRefetch && shouldRefetchThisLevel) {\n        result[3] = \"refetch\";\n    } else if (segmentMatches && refresh) {\n        result[3] = refresh;\n    }\n    if (segmentMatches && isRootLayout) {\n        result[4] = isRootLayout;\n    }\n    return result;\n}\n\n//# sourceMappingURL=create-optimistic-tree.js.map"],"names":[],"mappings":";;;;;;AAIW,SAAS,qBAAqB,QAAQ,EAAE,iBAAiB,EAAE,aAAa;IAC/E,MAAM,CAAC,iBAAiB,wBAAwB,KAAK,SAAS,aAAa,GAAG,qBAAqB;QAC/F;QACA,CAAC;KACJ;IACD,MAAM,UAAU,QAAQ,CAAC,EAAE;IAC3B,MAAM,gBAAgB,SAAS,MAAM,KAAK;IAC1C,MAAM,iBAAiB,oBAAoB,QAAQ,0LAAa,iBAAiB;IACjF,+EAA+E;IAC/E,yEAAyE;IACzE,8CAA8C;IAC9C,MAAM,4BAA4B,OAAO,IAAI,CAAC,wBAAwB,MAAM,GAAG;IAC/E,MAAM,yBAAyB,CAAC,qBAAqB,CAAC,kBAAkB;IACxE,IAAI,iBAAiB,CAAC;IACtB,IAAI,oBAAoB,QAAQ,gBAAgB;QAC5C,iBAAiB;IACrB;IACA,IAAI;IACJ,4EAA4E;IAC5E,0EAA0E;IAC1E,0BAA0B;IAC1B,IAAI,CAAC,iBAAiB,CAAC,2BAA2B;QAC9C,MAAM,YAAY,qBAAqB,SAAS,KAAK,CAAC,IAAI,iBAAiB,eAAe,QAAQ,GAAG,MAAM,iBAAiB;QAC5H,YAAY;IAChB;IACA,MAAM,SAAS;QACX;QACA;YACI,GAAG,cAAc;YACjB,GAAG,YAAY;gBACX,UAAU;YACd,IAAI,CAAC,CAAC;QACV;KACH;IACD,IAAI,KAAK;QACL,MAAM,CAAC,EAAE,GAAG;IAChB;IACA,IAAI,CAAC,iBAAiB,wBAAwB;QAC1C,MAAM,CAAC,EAAE,GAAG;IAChB,OAAO,IAAI,kBAAkB,SAAS;QAClC,MAAM,CAAC,EAAE,GAAG;IAChB;IACA,IAAI,kBAAkB,cAAc;QAChC,MAAM,CAAC,EAAE,GAAG;IAChB;IACA,OAAO;AACX,EAEA,kDAAkD"}},
    {"offset": {"line": 941, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 946, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/fill-cache-with-data-property.js"],"sourcesContent":["import { CacheStates } from \"../../../shared/lib/app-router-context.shared-runtime\";\nimport { createRouterCacheKey } from \"./create-router-cache-key\";\n/**\n * Kick off fetch based on the common layout between two routes. Fill cache with data property holding the in-progress fetch.\n */ export function fillCacheWithDataProperty(newCache, existingCache, flightSegmentPath, fetchResponse, bailOnParallelRoutes) {\n    if (bailOnParallelRoutes === void 0) bailOnParallelRoutes = false;\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = createRouterCacheKey(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap || bailOnParallelRoutes && existingCache.parallelRoutes.size > 1) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // or the existing cache has multiple parallel routes\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return {\n            bailOptimistic: true\n        };\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                status: CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                status: CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2), fetchResponse);\n}\n\n//# sourceMappingURL=fill-cache-with-data-property.js.map"],"names":[],"mappings":";;;;;;;;AAIW,SAAS,0BAA0B,QAAQ,EAAE,aAAa,EAAE,iBAAiB,EAAE,aAAa,EAAE,oBAAoB;IACzH,IAAI,yBAAyB,KAAK,GAAG,uBAAuB;IAC5D,MAAM,cAAc,kBAAkB,MAAM,IAAI;IAChD,MAAM,CAAC,kBAAkB,QAAQ,GAAG;IACpC,MAAM,WAAW,sOAAqB;IACtC,MAAM,0BAA0B,cAAc,cAAc,CAAC,GAAG,CAAC;IACjE,IAAI,CAAC,2BAA2B,wBAAwB,cAAc,cAAc,CAAC,IAAI,GAAG,GAAG;QAC3F,6EAA6E;QAC7E,qDAAqD;QACrD,sEAAsE;QACtE,OAAO;YACH,gBAAgB;QACpB;IACJ;IACA,IAAI,kBAAkB,SAAS,cAAc,CAAC,GAAG,CAAC;IAClD,IAAI,CAAC,mBAAmB,oBAAoB,yBAAyB;QACjE,kBAAkB,IAAI,IAAI;QAC1B,SAAS,cAAc,CAAC,GAAG,CAAC,kBAAkB;IAClD;IACA,MAAM,yBAAyB,wBAAwB,GAAG,CAAC;IAC3D,IAAI,iBAAiB,gBAAgB,GAAG,CAAC;IACzC,yFAAyF;IACzF,IAAI,aAAa;QACb,IAAI,CAAC,kBAAkB,CAAC,eAAe,IAAI,IAAI,mBAAmB,wBAAwB;YACtF,gBAAgB,GAAG,CAAC,UAAU;gBAC1B,QAAQ,gPAAY,UAAU;gBAC9B,MAAM;gBACN,aAAa;gBACb,gBAAgB,IAAI;YACxB;QACJ;QACA;IACJ;IACA,IAAI,CAAC,kBAAkB,CAAC,wBAAwB;QAC5C,+EAA+E;QAC/E,IAAI,CAAC,gBAAgB;YACjB,gBAAgB,GAAG,CAAC,UAAU;gBAC1B,QAAQ,gPAAY,UAAU;gBAC9B,MAAM;gBACN,aAAa;gBACb,gBAAgB,IAAI;YACxB;QACJ;QACA;IACJ;IACA,IAAI,mBAAmB,wBAAwB;QAC3C,iBAAiB;YACb,QAAQ,eAAe,MAAM;YAC7B,MAAM,eAAe,IAAI;YACzB,aAAa,eAAe,WAAW;YACvC,gBAAgB,IAAI,IAAI,eAAe,cAAc;QACzD;QACA,gBAAgB,GAAG,CAAC,UAAU;IAClC;IACA,OAAO,0BAA0B,gBAAgB,wBAAwB,kBAAkB,KAAK,CAAC,IAAI;AACzG,EAEA,yDAAyD"}},
    {"offset": {"line": 1010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1015, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js"],"sourcesContent":["import { createRouterCacheKey } from \"./create-router-cache-key\";\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */ export function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = createRouterCacheKey(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(cacheKey);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\n\n//# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map"],"names":[],"mappings":";;;;;;AAGW,SAAS,sCAAsC,QAAQ,EAAE,aAAa,EAAE,iBAAiB;IAChG,MAAM,cAAc,kBAAkB,MAAM,IAAI;IAChD,MAAM,CAAC,kBAAkB,QAAQ,GAAG;IACpC,MAAM,WAAW,sOAAqB;IACtC,MAAM,0BAA0B,cAAc,cAAc,CAAC,GAAG,CAAC;IACjE,IAAI,CAAC,yBAAyB;QAC1B,6EAA6E;QAC7E,sEAAsE;QACtE;IACJ;IACA,IAAI,kBAAkB,SAAS,cAAc,CAAC,GAAG,CAAC;IAClD,IAAI,CAAC,mBAAmB,oBAAoB,yBAAyB;QACjE,kBAAkB,IAAI,IAAI;QAC1B,SAAS,cAAc,CAAC,GAAG,CAAC,kBAAkB;IAClD;IACA,iDAAiD;IACjD,IAAI,aAAa;QACb,gBAAgB,MAAM,CAAC;QACvB;IACJ;IACA,MAAM,yBAAyB,wBAAwB,GAAG,CAAC;IAC3D,IAAI,iBAAiB,gBAAgB,GAAG,CAAC;IACzC,IAAI,CAAC,kBAAkB,CAAC,wBAAwB;QAC5C,6EAA6E;QAC7E,sEAAsE;QACtE;IACJ;IACA,IAAI,mBAAmB,wBAAwB;QAC3C,iBAAiB;YACb,QAAQ,eAAe,MAAM;YAC7B,MAAM,eAAe,IAAI;YACzB,aAAa,eAAe,WAAW;YACvC,gBAAgB,IAAI,IAAI,eAAe,cAAc;QACzD;QACA,gBAAgB,GAAG,CAAC,UAAU;IAClC;IACA,sCAAsC,gBAAgB,wBAAwB,kBAAkB,KAAK,CAAC;AAC1G,EAEA,qEAAqE"}},
    {"offset": {"line": 1059, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1064, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/read-record-value.js"],"sourcesContent":["/**\n * Read record value or throw Promise if it's not resolved yet.\n */ export function readRecordValue(thenable) {\n    if (thenable.status === \"fulfilled\") {\n        return thenable.value;\n    } else {\n        throw thenable;\n    }\n}\n\n//# sourceMappingURL=read-record-value.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;AAAU,SAAS,gBAAgB,QAAQ;IACxC,IAAI,SAAS,MAAM,KAAK,aAAa;QACjC,OAAO,SAAS,KAAK;IACzB,OAAO;QACH,MAAM;IACV;AACJ,EAEA,6CAA6C"}},
    {"offset": {"line": 1076, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/navigate-reducer.js"],"sourcesContent":["import { CacheStates } from \"../../../../shared/lib/app-router-context.shared-runtime\";\nimport { fetchServerResponse } from \"../fetch-server-response\";\nimport { createRecordFromThenable } from \"../create-record-from-thenable\";\nimport { readRecordValue } from \"../read-record-value\";\nimport { createHrefFromUrl } from \"../create-href-from-url\";\nimport { invalidateCacheBelowFlightSegmentPath } from \"../invalidate-cache-below-flight-segmentpath\";\nimport { fillCacheWithDataProperty } from \"../fill-cache-with-data-property\";\nimport { createOptimisticTree } from \"../create-optimistic-tree\";\nimport { applyRouterStatePatchToTree } from \"../apply-router-state-patch-to-tree\";\nimport { shouldHardNavigate } from \"../should-hard-navigate\";\nimport { isNavigatingToNewRootLayout } from \"../is-navigating-to-new-root-layout\";\nimport { PrefetchKind } from \"../router-reducer-types\";\nimport { handleMutable } from \"../handle-mutable\";\nimport { applyFlightData } from \"../apply-flight-data\";\nimport { PrefetchCacheEntryStatus, getPrefetchEntryCacheStatus } from \"../get-prefetch-cache-entry-status\";\nimport { prunePrefetchCache } from \"./prune-prefetch-cache\";\nimport { prefetchQueue } from \"./prefetch-reducer\";\nexport function handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.previousTree = state.tree;\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return handleMutable(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === \"\") {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction addRefetchToLeafSegments(newCache, currentCache, flightSegmentPath, treePatch, data) {\n    let appliedPatch = false;\n    newCache.status = CacheStates.READY;\n    newCache.subTreeData = currentCache.subTreeData;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        const res = fillCacheWithDataProperty(newCache, currentCache, segmentPaths, data);\n        if (!(res == null ? void 0 : res.bailOptimistic)) {\n            appliedPatch = true;\n        }\n    }\n    return appliedPatch;\n}\nexport function navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, cache, mutable, forceOptimisticNavigation, shouldScroll } = action;\n    const { pathname, hash } = url;\n    const href = createHrefFromUrl(url);\n    const pendingPush = navigateType === \"push\";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    prunePrefetchCache(state.prefetchCache);\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n    if (isForCurrentTree) {\n        return handleMutable(state, mutable);\n    }\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    let prefetchValues = state.prefetchCache.get(createHrefFromUrl(url, false));\n    if (forceOptimisticNavigation && (prefetchValues == null ? void 0 : prefetchValues.kind) !== PrefetchKind.TEMPORARY) {\n        const segments = pathname.split(\"/\");\n        // TODO-APP: figure out something better for index pages\n        segments.push(\"__PAGE__\");\n        // Optimistic tree case.\n        // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n        const optimisticTree = createOptimisticTree(segments, state.tree, false);\n        // we need a copy of the cache in case we need to revert to it\n        const temporaryCacheNode = {\n            ...cache\n        };\n        // Copy subTreeData for the root node of the cache.\n        // Note: didn't do it above because typescript doesn't like it.\n        temporaryCacheNode.status = CacheStates.READY;\n        temporaryCacheNode.subTreeData = state.cache.subTreeData;\n        temporaryCacheNode.parallelRoutes = new Map(state.cache.parallelRoutes);\n        let data = null;\n        const fetchResponse = ()=>{\n            if (!data) {\n                data = createRecordFromThenable(fetchServerResponse(url, optimisticTree, state.nextUrl, state.buildId));\n            }\n            return data;\n        };\n        // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.\n        // TODO-APP: re-evaluate if we need to strip the last segment\n        const optimisticFlightSegmentPath = segments.slice(1).map((segment)=>[\n                \"children\",\n                segment\n            ]).flat();\n        // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n        // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n        const res = fillCacheWithDataProperty(temporaryCacheNode, state.cache, optimisticFlightSegmentPath, fetchResponse, true);\n        // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n        if (!(res == null ? void 0 : res.bailOptimistic)) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = optimisticTree;\n            mutable.pendingPush = pendingPush;\n            mutable.hashFragment = hash;\n            mutable.shouldScroll = shouldScroll;\n            mutable.scrollableSegments = [];\n            mutable.cache = temporaryCacheNode;\n            mutable.canonicalUrl = href;\n            state.prefetchCache.set(createHrefFromUrl(url, false), {\n                data: data ? createRecordFromThenable(Promise.resolve(data)) : null,\n                // this will make sure that the entry will be discarded after 30s\n                kind: PrefetchKind.TEMPORARY,\n                prefetchTime: Date.now(),\n                treeAtTimeOfPrefetch: state.tree,\n                lastUsedTime: Date.now()\n            });\n            return handleMutable(state, mutable);\n        }\n    }\n    // If we don't have a prefetch value, we need to create one\n    if (!prefetchValues) {\n        const data = createRecordFromThenable(fetchServerResponse(url, state.tree, state.nextUrl, state.buildId, // in dev, there's never gonna be a prefetch entry so we want to prefetch here\n        // in order to simulate the behavior of the prefetch cache\n        process.env.NODE_ENV === \"development\" ? PrefetchKind.AUTO : undefined));\n        const newPrefetchValue = {\n            data: createRecordFromThenable(Promise.resolve(data)),\n            // this will make sure that the entry will be discarded after 30s\n            kind: process.env.NODE_ENV === \"development\" ? PrefetchKind.AUTO : PrefetchKind.TEMPORARY,\n            prefetchTime: Date.now(),\n            treeAtTimeOfPrefetch: state.tree,\n            lastUsedTime: null\n        };\n        state.prefetchCache.set(createHrefFromUrl(url, false), newPrefetchValue);\n        prefetchValues = newPrefetchValue;\n    }\n    const prefetchEntryCacheStatus = getPrefetchEntryCacheStatus(prefetchValues);\n    // The one before last item is the router state tree patch\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    prefetchQueue.bump(data);\n    // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n    const [flightData, canonicalUrlOverride, postponed] = readRecordValue(data);\n    // we only want to mark this once\n    if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now();\n    }\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return handleExternalUrl(state, mutable, flightData, pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    let scrollableSegments = [];\n    for (const flightDataPath of flightData){\n        const flightSegmentPath = flightDataPath.slice(0, -4);\n        // The one before last item is the router state tree patch\n        const treePatch = flightDataPath.slice(-3)[0];\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = [\n            \"\",\n            ...flightSegmentPath\n        ];\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n        flightSegmentPathWithLeadingEmpty, currentTree, treePatch);\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n            newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch);\n        }\n        if (newTree !== null) {\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n                return handleExternalUrl(state, mutable, href, pendingPush);\n            }\n            // TODO-APP: If the prefetch was postponed, we don't want to apply it\n            // until we land router changes to handle the postponed case.\n            let applied = postponed ? false : applyFlightData(currentCache, cache, flightDataPath, prefetchValues.kind === \"auto\" && prefetchEntryCacheStatus === PrefetchCacheEntryStatus.reusable);\n            if (!applied && prefetchEntryCacheStatus === PrefetchCacheEntryStatus.stale) {\n                applied = addRefetchToLeafSegments(cache, currentCache, flightSegmentPath, treePatch, // eslint-disable-next-line no-loop-func\n                ()=>createRecordFromThenable(fetchServerResponse(url, currentTree, state.nextUrl, state.buildId)));\n            }\n            const hardNavigate = shouldHardNavigate(// TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty, currentTree);\n            if (hardNavigate) {\n                cache.status = CacheStates.READY;\n                // Copy subTreeData for the root node of the cache.\n                cache.subTreeData = currentCache.subTreeData;\n                invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);\n                // Ensure the existing cache value is used when the cache was not invalidated.\n                mutable.cache = cache;\n            } else if (applied) {\n                mutable.cache = cache;\n            }\n            currentCache = cache;\n            currentTree = newTree;\n            for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                const scrollableSegmentPath = [\n                    ...flightSegmentPath,\n                    ...subSegment\n                ];\n                // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== \"__DEFAULT__\") {\n                    scrollableSegments.push(scrollableSegmentPath);\n                }\n            }\n        }\n    }\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = currentTree;\n    mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = scrollableSegments;\n    mutable.hashFragment = hash;\n    mutable.shouldScroll = shouldScroll;\n    return handleMutable(state, mutable);\n}\n\n//# sourceMappingURL=navigate-reducer.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1340, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/server-action-reducer.js"],"sourcesContent":["import { callServer } from \"../../../app-call-server\";\nimport { ACTION, NEXT_ROUTER_STATE_TREE, NEXT_URL, RSC_CONTENT_TYPE_HEADER } from \"../../app-router-headers\";\nimport { createRecordFromThenable } from \"../create-record-from-thenable\";\nimport { readRecordValue } from \"../read-record-value\";\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, encodeReply } = !!process.env.NEXT_RUNTIME ? require(\"react-server-dom-webpack/client.edge\") : require(\"react-server-dom-webpack/client\");\nimport { addBasePath } from \"../../../add-base-path\";\nimport { createHrefFromUrl } from \"../create-href-from-url\";\nimport { handleExternalUrl } from \"./navigate-reducer\";\nimport { applyRouterStatePatchToTree } from \"../apply-router-state-patch-to-tree\";\nimport { isNavigatingToNewRootLayout } from \"../is-navigating-to-new-root-layout\";\nimport { CacheStates } from \"../../../../shared/lib/app-router-context.shared-runtime\";\nimport { handleMutable } from \"../handle-mutable\";\nimport { fillLazyItemsTillLeafWithHead } from \"../fill-lazy-items-till-leaf-with-head\";\nasync function fetchServerAction(state, param) {\n    let { actionId, actionArgs } = param;\n    const body = await encodeReply(actionArgs);\n    const res = await fetch(\"\", {\n        method: \"POST\",\n        headers: {\n            Accept: RSC_CONTENT_TYPE_HEADER,\n            [ACTION]: actionId,\n            [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),\n            ...process.env.__NEXT_ACTIONS_DEPLOYMENT_ID && process.env.NEXT_DEPLOYMENT_ID ? {\n                \"x-deployment-id\": process.env.NEXT_DEPLOYMENT_ID\n            } : {},\n            ...state.nextUrl ? {\n                [NEXT_URL]: state.nextUrl\n            } : {}\n        },\n        body\n    });\n    const location = res.headers.get(\"x-action-redirect\");\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get(\"x-action-revalidated\") || \"[[],0,0]\");\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? new URL(addBasePath(location), // Ensure relative redirects in Server Actions work, e.g. redirect('./somewhere-else')\n    new URL(state.canonicalUrl, window.location.href)) : undefined;\n    let isFlightResponse = res.headers.get(\"content-type\") === RSC_CONTENT_TYPE_HEADER;\n    if (isFlightResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            const [, actionFlightData] = response != null ? response : [];\n            return {\n                actionFlightData: actionFlightData,\n                redirectLocation,\n                revalidatedParts\n            };\n        }\n        // otherwise it's a tuple of [actionResult, actionFlightData]\n        const [actionResult, [, actionFlightData]] = response != null ? response : [];\n        return {\n            actionResult,\n            actionFlightData,\n            redirectLocation,\n            revalidatedParts\n        };\n    }\n    return {\n        redirectLocation,\n        revalidatedParts\n    };\n}\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */ export function serverActionReducer(state, action) {\n    const { mutable, cache, resolve, reject } = action;\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(currentTree);\n    if (isForCurrentTree) {\n        return handleMutable(state, mutable);\n    }\n    if (mutable.inFlightServerAction) {\n        // unblock if a navigation event comes through\n        // while we've suspended on an action\n        if (mutable.inFlightServerAction.status !== \"fulfilled\" && mutable.globalMutable.pendingNavigatePath && mutable.globalMutable.pendingNavigatePath !== href) {\n            mutable.inFlightServerAction.then(()=>{\n                if (mutable.actionResultResolved) return;\n                // if the server action resolves after a navigation took place,\n                // reset ServerActionMutable values & trigger a refresh so that any stale data gets updated\n                mutable.inFlightServerAction = null;\n                mutable.globalMutable.pendingNavigatePath = undefined;\n                mutable.globalMutable.refresh();\n                mutable.actionResultResolved = true;\n            }, ()=>{});\n            return state;\n        }\n    } else {\n        mutable.inFlightServerAction = createRecordFromThenable(fetchServerAction(state, action));\n    }\n    // TODO-APP: Make try/catch wrap only readRecordValue so that other errors bubble up through the reducer instead.\n    try {\n        // suspends until the server action is resolved.\n        const { actionResult, actionFlightData: flightData, redirectLocation } = readRecordValue(mutable.inFlightServerAction);\n        // Make sure the redirection is a push instead of a replace.\n        // Issue: https://github.com/vercel/next.js/issues/53911\n        if (redirectLocation) {\n            state.pushRef.pendingPush = true;\n            mutable.pendingPush = true;\n        }\n        mutable.previousTree = state.tree;\n        if (!flightData) {\n            if (!mutable.actionResultResolved) {\n                resolve(actionResult);\n                mutable.actionResultResolved = true;\n            }\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return handleExternalUrl(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === \"string\") {\n            // Handle case when navigating to page in `pages` from `app`\n            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.data as it has been resolved at this point.\n        mutable.inFlightServerAction = null;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log(\"SERVER ACTION APPLY FAILED\");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and subTreeData for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n            [\n                \"\"\n            ], currentTree, treePatch);\n            if (newTree === null) {\n                throw new Error(\"SEGMENT MISMATCH\");\n            }\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n            }\n            // The one before last item is the router state tree patch\n            const [subTreeData, head] = flightDataPath.slice(-2);\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (subTreeData !== null) {\n                cache.status = CacheStates.READY;\n                cache.subTreeData = subTreeData;\n                fillLazyItemsTillLeafWithHead(cache, // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n                undefined, treePatch, head);\n                mutable.cache = cache;\n                mutable.prefetchCache = new Map();\n            }\n            mutable.previousTree = currentTree;\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        if (redirectLocation) {\n            const newHref = createHrefFromUrl(redirectLocation, false);\n            mutable.canonicalUrl = newHref;\n        }\n        if (!mutable.actionResultResolved) {\n            resolve(actionResult);\n            mutable.actionResultResolved = true;\n        }\n        return handleMutable(state, mutable);\n    } catch (e) {\n        if (e.status === \"rejected\") {\n            if (!mutable.actionResultResolved) {\n                reject(e.reason);\n                mutable.actionResultResolved = true;\n            }\n            // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n            return state;\n        }\n        throw e;\n    }\n}\n\n//# sourceMappingURL=server-action-reducer.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1542, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1547, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/fast-refresh-reducer.js"],"sourcesContent":["import { fetchServerResponse } from \"../fetch-server-response\";\nimport { createRecordFromThenable } from \"../create-record-from-thenable\";\nimport { readRecordValue } from \"../read-record-value\";\nimport { createHrefFromUrl } from \"../create-href-from-url\";\nimport { applyRouterStatePatchToTree } from \"../apply-router-state-patch-to-tree\";\nimport { isNavigatingToNewRootLayout } from \"../is-navigating-to-new-root-layout\";\nimport { handleExternalUrl } from \"./navigate-reducer\";\nimport { handleMutable } from \"../handle-mutable\";\nimport { applyFlightData } from \"../apply-flight-data\";\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction fastRefreshReducerImpl(state, action) {\n    const { cache, mutable, origin } = action;\n    const href = state.canonicalUrl;\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n    if (isForCurrentTree) {\n        return handleMutable(state, mutable);\n    }\n    if (!cache.data) {\n        // TODO-APP: verify that `href` is not an external url.\n        // Fetch data from the root of the tree.\n        cache.data = createRecordFromThenable(fetchServerResponse(new URL(href, origin), [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            \"refetch\"\n        ], state.nextUrl, state.buildId));\n    }\n    const [flightData, canonicalUrlOverride] = readRecordValue(cache.data);\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    // Remove cache.data as it has been resolved at this point.\n    cache.data = null;\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const flightDataPath of flightData){\n        // FlightDataPath with more than two items means unexpected Flight data was returned\n        if (flightDataPath.length !== 3) {\n            // TODO-APP: handle this case better\n            console.log(\"REFRESH FAILED\");\n            return state;\n        }\n        // Given the path can only have two items the items are only the router state and subTreeData for the root.\n        const [treePatch] = flightDataPath;\n        const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n        [\n            \"\"\n        ], currentTree, treePatch);\n        if (newTree === null) {\n            throw new Error(\"SEGMENT MISMATCH\");\n        }\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n        if (canonicalUrlOverride) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const applied = applyFlightData(currentCache, cache, flightDataPath);\n        if (applied) {\n            mutable.cache = cache;\n            currentCache = cache;\n        }\n        mutable.previousTree = currentTree;\n        mutable.patchedTree = newTree;\n        mutable.canonicalUrl = href;\n        currentTree = newTree;\n    }\n    return handleMutable(state, mutable);\n}\nfunction fastRefreshReducerNoop(state, _action) {\n    return state;\n}\nexport const fastRefreshReducer = process.env.NODE_ENV === \"production\" ? fastRefreshReducerNoop : fastRefreshReducerImpl;\n\n//# sourceMappingURL=fast-refresh-reducer.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AASA,wFAAwF;AACxF,SAAS,uBAAuB,KAAK,EAAE,MAAM;IACzC,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG;IACnC,MAAM,OAAO,MAAM,YAAY;IAC/B,MAAM,mBAAmB,KAAK,SAAS,CAAC,QAAQ,YAAY,MAAM,KAAK,SAAS,CAAC,MAAM,IAAI;IAC3F,IAAI,kBAAkB;QAClB,OAAO,gNAAc,OAAO;IAChC;IACA,IAAI,CAAC,MAAM,IAAI,EAAE;QACb,uDAAuD;QACvD,wCAAwC;QACxC,MAAM,IAAI,GAAG,8OAAyB,gOAAoB,IAAI,IAAI,MAAM,SAAS;YAC7E,MAAM,IAAI,CAAC,EAAE;YACb,MAAM,IAAI,CAAC,EAAE;YACb,MAAM,IAAI,CAAC,EAAE;YACb;SACH,EAAE,MAAM,OAAO,EAAE,MAAM,OAAO;IACnC;IACA,MAAM,CAAC,YAAY,qBAAqB,GAAG,wNAAgB,MAAM,IAAI;IACrE,4DAA4D;IAC5D,IAAI,OAAO,eAAe,UAAU;QAChC,OAAO,kOAAkB,OAAO,SAAS,YAAY,MAAM,OAAO,CAAC,WAAW;IAClF;IACA,2DAA2D;IAC3D,MAAM,IAAI,GAAG;IACb,IAAI,cAAc,MAAM,IAAI;IAC5B,IAAI,eAAe,MAAM,KAAK;IAC9B,KAAK,MAAM,kBAAkB,WAAW;QACpC,oFAAoF;QACpF,IAAI,eAAe,MAAM,KAAK,GAAG;YAC7B,oCAAoC;YACpC,QAAQ,GAAG,CAAC;YACZ,OAAO;QACX;QACA,2GAA2G;QAC3G,MAAM,CAAC,UAAU,GAAG;QACpB,MAAM,UAAU,4PAChB;YACI;SACH,EAAE,aAAa;QAChB,IAAI,YAAY,MAAM;YAClB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,4PAA4B,aAAa,UAAU;YACnD,OAAO,kOAAkB,OAAO,SAAS,MAAM,MAAM,OAAO,CAAC,WAAW;QAC5E;QACA,MAAM,2BAA2B,uBAAuB,gOAAkB,wBAAwB;QAClG,IAAI,sBAAsB;YACtB,QAAQ,YAAY,GAAG;QAC3B;QACA,MAAM,UAAU,wNAAgB,cAAc,OAAO;QACrD,IAAI,SAAS;YACT,QAAQ,KAAK,GAAG;YAChB,eAAe;QACnB;QACA,QAAQ,YAAY,GAAG;QACvB,QAAQ,WAAW,GAAG;QACtB,QAAQ,YAAY,GAAG;QACvB,cAAc;IAClB;IACA,OAAO,gNAAc,OAAO;AAChC;AACA,SAAS,uBAAuB,KAAK,EAAE,OAAO;IAC1C,OAAO;AACX;AACO,MAAM,qBAAqB,6EAAiE,wBAEnG,gDAAgD"}},
    {"offset": {"line": 1634, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1639, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/refresh-reducer.js"],"sourcesContent":["import { fetchServerResponse } from \"../fetch-server-response\";\nimport { createRecordFromThenable } from \"../create-record-from-thenable\";\nimport { readRecordValue } from \"../read-record-value\";\nimport { createHrefFromUrl } from \"../create-href-from-url\";\nimport { applyRouterStatePatchToTree } from \"../apply-router-state-patch-to-tree\";\nimport { isNavigatingToNewRootLayout } from \"../is-navigating-to-new-root-layout\";\nimport { handleExternalUrl } from \"./navigate-reducer\";\nimport { handleMutable } from \"../handle-mutable\";\nimport { CacheStates } from \"../../../../shared/lib/app-router-context.shared-runtime\";\nimport { fillLazyItemsTillLeafWithHead } from \"../fill-lazy-items-till-leaf-with-head\";\nexport function refreshReducer(state, action) {\n    const { cache, mutable, origin } = action;\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(currentTree);\n    if (isForCurrentTree) {\n        return handleMutable(state, mutable);\n    }\n    if (!cache.data) {\n        // TODO-APP: verify that `href` is not an external url.\n        // Fetch data from the root of the tree.\n        cache.data = createRecordFromThenable(fetchServerResponse(new URL(href, origin), [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            \"refetch\"\n        ], state.nextUrl, state.buildId));\n    }\n    const [flightData, canonicalUrlOverride] = readRecordValue(cache.data);\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    // Remove cache.data as it has been resolved at this point.\n    cache.data = null;\n    for (const flightDataPath of flightData){\n        // FlightDataPath with more than two items means unexpected Flight data was returned\n        if (flightDataPath.length !== 3) {\n            // TODO-APP: handle this case better\n            console.log(\"REFRESH FAILED\");\n            return state;\n        }\n        // Given the path can only have two items the items are only the router state and subTreeData for the root.\n        const [treePatch] = flightDataPath;\n        const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n        [\n            \"\"\n        ], currentTree, treePatch);\n        if (newTree === null) {\n            throw new Error(\"SEGMENT MISMATCH\");\n        }\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n        if (canonicalUrlOverride) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        // The one before last item is the router state tree patch\n        const [subTreeData, head] = flightDataPath.slice(-2);\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (subTreeData !== null) {\n            cache.status = CacheStates.READY;\n            cache.subTreeData = subTreeData;\n            fillLazyItemsTillLeafWithHead(cache, // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined, treePatch, head);\n            mutable.cache = cache;\n            mutable.prefetchCache = new Map();\n        }\n        mutable.previousTree = currentTree;\n        mutable.patchedTree = newTree;\n        mutable.canonicalUrl = href;\n        currentTree = newTree;\n    }\n    return handleMutable(state, mutable);\n}\n\n//# sourceMappingURL=refresh-reducer.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAUO,SAAS,eAAe,KAAK,EAAE,MAAM;IACxC,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG;IACnC,MAAM,OAAO,MAAM,YAAY;IAC/B,IAAI,cAAc,MAAM,IAAI;IAC5B,MAAM,mBAAmB,KAAK,SAAS,CAAC,QAAQ,YAAY,MAAM,KAAK,SAAS,CAAC;IACjF,IAAI,kBAAkB;QAClB,OAAO,gNAAc,OAAO;IAChC;IACA,IAAI,CAAC,MAAM,IAAI,EAAE;QACb,uDAAuD;QACvD,wCAAwC;QACxC,MAAM,IAAI,GAAG,8OAAyB,gOAAoB,IAAI,IAAI,MAAM,SAAS;YAC7E,WAAW,CAAC,EAAE;YACd,WAAW,CAAC,EAAE;YACd,WAAW,CAAC,EAAE;YACd;SACH,EAAE,MAAM,OAAO,EAAE,MAAM,OAAO;IACnC;IACA,MAAM,CAAC,YAAY,qBAAqB,GAAG,wNAAgB,MAAM,IAAI;IACrE,4DAA4D;IAC5D,IAAI,OAAO,eAAe,UAAU;QAChC,OAAO,kOAAkB,OAAO,SAAS,YAAY,MAAM,OAAO,CAAC,WAAW;IAClF;IACA,2DAA2D;IAC3D,MAAM,IAAI,GAAG;IACb,KAAK,MAAM,kBAAkB,WAAW;QACpC,oFAAoF;QACpF,IAAI,eAAe,MAAM,KAAK,GAAG;YAC7B,oCAAoC;YACpC,QAAQ,GAAG,CAAC;YACZ,OAAO;QACX;QACA,2GAA2G;QAC3G,MAAM,CAAC,UAAU,GAAG;QACpB,MAAM,UAAU,4PAChB;YACI;SACH,EAAE,aAAa;QAChB,IAAI,YAAY,MAAM;YAClB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,4PAA4B,aAAa,UAAU;YACnD,OAAO,kOAAkB,OAAO,SAAS,MAAM,MAAM,OAAO,CAAC,WAAW;QAC5E;QACA,MAAM,2BAA2B,uBAAuB,gOAAkB,wBAAwB;QAClG,IAAI,sBAAsB;YACtB,QAAQ,YAAY,GAAG;QAC3B;QACA,0DAA0D;QAC1D,MAAM,CAAC,aAAa,KAAK,GAAG,eAAe,KAAK,CAAC,CAAC;QAClD,8FAA8F;QAC9F,IAAI,gBAAgB,MAAM;YACtB,MAAM,MAAM,GAAG,gPAAY,KAAK;YAChC,MAAM,WAAW,GAAG;YACpB,oQAA8B,OAC9B,WAAW,WAAW;YACtB,QAAQ,KAAK,GAAG;YAChB,QAAQ,aAAa,GAAG,IAAI;QAChC;QACA,QAAQ,YAAY,GAAG;QACvB,QAAQ,WAAW,GAAG;QACtB,QAAQ,YAAY,GAAG;QACvB,cAAc;IAClB;IACA,OAAO,gNAAc,OAAO;AAChC,EAEA,2CAA2C"}},
    {"offset": {"line": 1727, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1732, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/restore-reducer.js"],"sourcesContent":["import { createHrefFromUrl } from \"../create-href-from-url\";\nexport function restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = createHrefFromUrl(url);\n    return {\n        buildId: state.buildId,\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: state.pushRef,\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: state.cache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: tree,\n        nextUrl: url.pathname\n    };\n}\n\n//# sourceMappingURL=restore-reducer.js.map"],"names":[],"mappings":";;;;;;AACO,SAAS,eAAe,KAAK,EAAE,MAAM;IACxC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IACtB,MAAM,OAAO,gOAAkB;IAC/B,OAAO;QACH,SAAS,MAAM,OAAO;QACtB,oBAAoB;QACpB,cAAc;QACd,SAAS,MAAM,OAAO;QACtB,mBAAmB,MAAM,iBAAiB;QAC1C,OAAO,MAAM,KAAK;QAClB,eAAe,MAAM,aAAa;QAClC,wBAAwB;QACxB,MAAM;QACN,SAAS,IAAI,QAAQ;IACzB;AACJ,EAEA,2CAA2C"}},
    {"offset": {"line": 1754, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1759, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/server-patch-reducer.js"],"sourcesContent":["import { createHrefFromUrl } from \"../create-href-from-url\";\nimport { applyRouterStatePatchToTree } from \"../apply-router-state-patch-to-tree\";\nimport { isNavigatingToNewRootLayout } from \"../is-navigating-to-new-root-layout\";\nimport { handleExternalUrl } from \"./navigate-reducer\";\nimport { applyFlightData } from \"../apply-flight-data\";\nimport { handleMutable } from \"../handle-mutable\";\nexport function serverPatchReducer(state, action) {\n    const { flightData, previousTree, overrideCanonicalUrl, cache, mutable } = action;\n    const isForCurrentTree = JSON.stringify(previousTree) === JSON.stringify(state.tree);\n    // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n    // In that case opt-out of applying the patch given that the data could be stale.\n    if (!isForCurrentTree) {\n        // TODO-APP: Handle tree mismatch\n        console.log(\"TREE MISMATCH\");\n        // Keep everything as-is.\n        return state;\n    }\n    if (mutable.previousTree) {\n        return handleMutable(state, mutable);\n    }\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const flightDataPath of flightData){\n        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n        const flightSegmentPath = flightDataPath.slice(0, -4);\n        const [treePatch] = flightDataPath.slice(-3, -2);\n        const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n        [\n            \"\",\n            ...flightSegmentPath\n        ], currentTree, treePatch);\n        if (newTree === null) {\n            throw new Error(\"SEGMENT MISMATCH\");\n        }\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        applyFlightData(currentCache, cache, flightDataPath);\n        mutable.previousTree = currentTree;\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return handleMutable(state, mutable);\n}\n\n//# sourceMappingURL=server-patch-reducer.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAMO,SAAS,mBAAmB,KAAK,EAAE,MAAM;IAC5C,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,oBAAoB,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG;IAC3E,MAAM,mBAAmB,KAAK,SAAS,CAAC,kBAAkB,KAAK,SAAS,CAAC,MAAM,IAAI;IACnF,kIAAkI;IAClI,iFAAiF;IACjF,IAAI,CAAC,kBAAkB;QACnB,iCAAiC;QACjC,QAAQ,GAAG,CAAC;QACZ,yBAAyB;QACzB,OAAO;IACX;IACA,IAAI,QAAQ,YAAY,EAAE;QACtB,OAAO,gNAAc,OAAO;IAChC;IACA,4DAA4D;IAC5D,IAAI,OAAO,eAAe,UAAU;QAChC,OAAO,kOAAkB,OAAO,SAAS,YAAY,MAAM,OAAO,CAAC,WAAW;IAClF;IACA,IAAI,cAAc,MAAM,IAAI;IAC5B,IAAI,eAAe,MAAM,KAAK;IAC9B,KAAK,MAAM,kBAAkB,WAAW;QACpC,mFAAmF;QACnF,MAAM,oBAAoB,eAAe,KAAK,CAAC,GAAG,CAAC;QACnD,MAAM,CAAC,UAAU,GAAG,eAAe,KAAK,CAAC,CAAC,GAAG,CAAC;QAC9C,MAAM,UAAU,4PAChB;YACI;eACG;SACN,EAAE,aAAa;QAChB,IAAI,YAAY,MAAM;YAClB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,4PAA4B,aAAa,UAAU;YACnD,OAAO,kOAAkB,OAAO,SAAS,MAAM,YAAY,EAAE,MAAM,OAAO,CAAC,WAAW;QAC1F;QACA,MAAM,2BAA2B,uBAAuB,gOAAkB,wBAAwB;QAClG,IAAI,0BAA0B;YAC1B,QAAQ,YAAY,GAAG;QAC3B;QACA,wNAAgB,cAAc,OAAO;QACrC,QAAQ,YAAY,GAAG;QACvB,QAAQ,WAAW,GAAG;QACtB,QAAQ,KAAK,GAAG;QAChB,eAAe;QACf,cAAc;IAClB;IACA,OAAO,gNAAc,OAAO;AAChC,EAEA,gDAAgD"}},
    {"offset": {"line": 1822, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1827, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/client/components/router-reducer/router-reducer.js"],"sourcesContent":["import { ACTION_NAVIGATE, ACTION_SERVER_PATCH, ACTION_RESTORE, ACTION_REFRESH, ACTION_PREFETCH, ACTION_FAST_REFRESH, ACTION_SERVER_ACTION } from \"./router-reducer-types\";\nimport { navigateReducer } from \"./reducers/navigate-reducer\";\nimport { serverPatchReducer } from \"./reducers/server-patch-reducer\";\nimport { restoreReducer } from \"./reducers/restore-reducer\";\nimport { refreshReducer } from \"./reducers/refresh-reducer\";\nimport { prefetchReducer } from \"./reducers/prefetch-reducer\";\nimport { fastRefreshReducer } from \"./reducers/fast-refresh-reducer\";\nimport { serverActionReducer } from \"./reducers/server-action-reducer\";\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case ACTION_NAVIGATE:\n            {\n                return navigateReducer(state, action);\n            }\n        case ACTION_SERVER_PATCH:\n            {\n                return serverPatchReducer(state, action);\n            }\n        case ACTION_RESTORE:\n            {\n                return restoreReducer(state, action);\n            }\n        case ACTION_REFRESH:\n            {\n                return refreshReducer(state, action);\n            }\n        case ACTION_FAST_REFRESH:\n            {\n                return fastRefreshReducer(state, action);\n            }\n        case ACTION_PREFETCH:\n            {\n                return prefetchReducer(state, action);\n            }\n        case ACTION_SERVER_ACTION:\n            {\n                return serverActionReducer(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer = typeof window === \"undefined\" ? serverReducer : clientReducer;\n\n//# sourceMappingURL=router-reducer.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAQA;;CAEC,GAAG,SAAS,cAAc,KAAK,EAAE,MAAM;IACpC,OAAO,OAAO,IAAI;QACd;YACI;gBACI,OAAO,gOAAgB,OAAO;YAClC;QACJ;YACI;gBACI,OAAO,0OAAmB,OAAO;YACrC;QACJ;YACI;gBACI,OAAO,8NAAe,OAAO;YACjC;QACJ;YACI;gBACI,OAAO,8NAAe,OAAO;YACjC;QACJ;YACI;gBACI,OAAO,0OAAmB,OAAO;YACrC;QACJ;YACI;gBACI,OAAO,gOAAgB,OAAO;YAClC;QACJ;YACI;gBACI,OAAO,4OAAoB,OAAO;YACtC;QACJ,+DAA+D;QAC/D;YACI,MAAM,IAAI,MAAM;IACxB;AACJ;AACA,SAAS,cAAc,KAAK,EAAE,OAAO;IACjC,OAAO;AACX;AAEO,MAAM,UAAU,OAAO,WAAW,cAAc,gBAAgB,eAEvE,0CAA0C"}},
    {"offset": {"line": 1888, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}